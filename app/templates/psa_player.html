<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="robots" content="noindex, nofollow">
    <title>Media Player</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        .countdown-badge {
            font-size: 1.05rem;
            min-width: 120px;
            text-align: center;
        }
        .countdown-flash {
            animation: flash 0.25s steps(1) infinite;
        }
        @keyframes flash {
            50% { opacity: 0.35; }
        }
        .cue-btn.active {
            background: #000;
            color: #fff !important;
        }
    </style>
</head>
<body>
{% include '_nav.html' %}
<div class="container mt-4">
    <div class="d-flex justify-content-between align-items-center mb-3">
        <div>
            <h2 class="mb-0">Media Player</h2>
            <div class="text-muted">Queue and play music, PSAs, imaging, and show assets directly in the browser.</div>
            <div class="help-hint text-info">This page is noindex/nofollow. Share the URL directly with DJs.</div>
        </div>
        <div class="text-muted small">Source: {{ psa_root or 'psa' }}</div>
    </div>
    <div class="row g-3">
        <div class="col-lg-6">
            <div class="card h-100">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <span>Available Media</span>
                    <div class="d-flex gap-2 align-items-center">
                        <button class="btn btn-outline-secondary btn-sm" id="refreshPsa">Refresh</button>
                        <select id="categoryFilter" class="form-select form-select-sm" style="max-width:180px;"></select>
                        <input type="search" id="psaSearch" class="form-control form-control-sm" placeholder="Filter..." style="max-width:200px;">
                    </div>
                </div>
                <div class="card-body" style="max-height:60vh; overflow:auto;">
                    <ul class="list-group" id="psaList"></ul>
                </div>
                <div class="card-footer d-flex justify-content-between align-items-center">
                    <div class="text-muted small" id="libraryMeta">Loading...</div>
                    <div class="btn-group btn-group-sm">
                        <button class="btn btn-outline-secondary" id="libraryPrev">Prev</button>
                        <button class="btn btn-outline-secondary" id="libraryNext">Next</button>
                    </div>
                </div>
            </div>
        </div>
        <div class="col-lg-6">
            <div class="card h-100">
                <div class="card-header d-flex justify-content-between align-items-center flex-wrap gap-2">
                    <div class="d-flex align-items-center gap-2 flex-wrap">
                        <span>Queue</span>
                        <span class="badge text-bg-light border" id="controlModeLabel">RAMS</span>
                        <button class="btn btn-outline-secondary btn-sm" id="radiodjOverride">RadioDJ Override</button>
                    </div>
                    <div class="text-muted fw-semibold" style="font-size:1.4rem;">Timer: <span id="timerTop">00:00.00</span></div>
                </div>
                <div class="card-body">
                    <div class="alert alert-secondary py-2 px-3 mb-2" id="radiodjStatus">
                        <strong>RadioDJ now playing:</strong> <span id="radiodjTrack">Loading…</span>
                    </div>
                    <div class="d-flex align-items-center justify-content-between mb-2 flex-wrap gap-2">
                        <div class="fw-semibold" style="font-size:1.8rem;">Timer: <span id="timer">00:00.00</span></div>
                        <div class="d-flex gap-2 align-items-center">
                            <span class="badge rounded-pill text-bg-secondary countdown-badge" id="introBadge" style="display:none;">Intro</span>
                            <span class="badge rounded-pill text-bg-secondary countdown-badge" id="outroBadge" style="display:none;">Outro</span>
                        </div>
                    </div>
                    <audio id="psaAudioA" controls class="w-100 mb-2"></audio>
                    <audio id="psaAudioB" class="w-100 mb-2 d-none"></audio>
                    <audio id="psaAudioOverlay" class="w-100 mb-2"></audio>
                    <div class="d-flex align-items-center justify-content-between mb-2">
                        <div class="d-flex flex-column gap-1">
                            <div class="form-check mb-0">
                                <input class="form-check-input" type="checkbox" id="top40">
                                <label class="form-check-label" for="top40">Top-40 boost (+0.5 semitone on music)</label>
                            </div>
                            <div class="form-check mb-0">
                                <input class="form-check-input" type="checkbox" id="loopBetween" disabled>
                                <label class="form-check-label" for="loopBetween">Loop between loop-in / loop-out cues</label>
                            </div>
                        </div>
                        <div class="d-flex gap-2">
                            <button class="btn btn-outline-dark btn-sm" id="startRecord">Record VT</button>
                            <button class="btn btn-outline-secondary btn-sm" id="stopRecord" disabled>Stop</button>
                        </div>
                    </div>
                    <div id="vtPending" class="alert alert-info d-none py-2 px-3 mb-2">
                        <div class="d-flex justify-content-between align-items-center flex-wrap gap-2">
                            <div>Pending voice track ready. Add to queue?</div>
                            <div class="d-flex gap-2">
                                <button class="btn btn-sm btn-outline-success" id="vtConfirm">Confirm</button>
                                <button class="btn btn-sm btn-outline-danger" id="vtDelete">Delete</button>
                            </div>
                        </div>
                    </div>
                    <div class="d-flex gap-2 flex-wrap mb-2">
                        <button class="btn btn-outline-secondary btn-sm" id="clearQueue">Clear Queue</button>
                        <button class="btn btn-outline-primary btn-sm" id="togglePause">Pause</button>
                        <button class="btn btn-outline-primary btn-sm" id="playNext">Play Next</button>
                        <button class="btn btn-outline-danger btn-sm" id="fadeOut">Fade & Next</button>
                        <button class="btn btn-outline-dark btn-sm" id="addStop">Add STOP</button>
                        <button class="btn btn-outline-warning btn-sm" id="pushQueue" disabled>Push Queue to RadioDJ</button>
                    </div>
                    <div class="text-muted small mb-2" id="radiodjQueueStatus"></div>
                    <ol class="mb-0" id="queueList"></ol>
                    <hr>
                    <div class="mb-2 fw-semibold">Overlay Deck</div>
                    <div class="input-group mb-2">
                        <input type="url" class="form-control form-control-sm" id="overlayUrl" placeholder="Paste media URL">
                        <button class="btn btn-outline-primary btn-sm" id="overlayPlay">Play Overlay</button>
                    </div>
                    <div class="text-muted small">Use the overlay deck for ad-hoc beds or carts; it does not affect the queue.</div>
                </div>
            </div>
        </div>
    </div>
</div>
{% include '_footer.html' %}
<script>
    let library = [];
    const psaList = document.getElementById('psaList');
    const queueList = document.getElementById('queueList');
    const timerEls = [document.getElementById('timer'), document.getElementById('timerTop')];
    const categoryFilter = document.getElementById('categoryFilter');
    const libraryMeta = document.getElementById('libraryMeta');
    const libraryPrev = document.getElementById('libraryPrev');
    const libraryNext = document.getElementById('libraryNext');
    const psaSearch = document.getElementById('psaSearch');
    const top40 = document.getElementById('top40');
    const loopBetween = document.getElementById('loopBetween');
    const togglePauseBtn = document.getElementById('togglePause');
    const playNextBtn = document.getElementById('playNext');
    const fadeOutBtn = document.getElementById('fadeOut');
    const addStopBtn = document.getElementById('addStop');
    const controlModeLabel = document.getElementById('controlModeLabel');
    const radiodjOverrideBtn = document.getElementById('radiodjOverride');
    const pushQueueBtn = document.getElementById('pushQueue');
    const radiodjStatus = document.getElementById('radiodjStatus');
    const radiodjTrack = document.getElementById('radiodjTrack');
    const radiodjQueueStatus = document.getElementById('radiodjQueueStatus');
    const introBadge = document.getElementById('introBadge');
    const outroBadge = document.getElementById('outroBadge');
    const queue = [];
    const players = [
        { el: document.getElementById('psaAudioA'), item: null },
        { el: document.getElementById('psaAudioB'), item: null }
    ];
    const overlayPlayer = document.getElementById('psaAudioOverlay');
    let currentIdx = 0;
    let currentItem = null;
    let fadeTimer = null;
    let timerInterval = null;
    let recorder = null;
    let recordChunks = [];
    let autoNextTriggered = false;
    let prestartedIdx = null;
    let pendingVT = null;
    let pendingVTUrl = null;
    let libraryPage = 1;
    let libraryTotal = 0;
    const libraryPerPage = 50;
    let libraryQuery = '';
    let controlMode = 'rams';

    function activePlayer() { return players[currentIdx].el; }
    function otherPlayer() { return players[1 - currentIdx].el; }

    function renderCategories(cats) {
        const options = cats || [];
        categoryFilter.innerHTML = '<option value="">All categories</option>' + options.map(c => `<option value="${c}">${c}</option>`).join('');
    }

    function renderLibrary(filter = '') {
        psaList.innerHTML = '';
        const term = filter.toLowerCase();
        const cat = categoryFilter.value;
        library.filter(item => item.name.toLowerCase().includes(term) && (!cat || item.category === cat)).forEach(item => {
            const li = document.createElement('li');
            li.className = 'list-group-item';
            const meta = [];
            if (item.duration) meta.push(`${item.duration}s`);
            if (item.loop) meta.push('loop');
            if (item.category) meta.push(item.category);
            li.innerHTML = `<div class="d-flex justify-content-between align-items-center">
                <div>
                    <strong>${item.name}</strong><br>
                    ${meta.length ? `<small class='text-muted'>${meta.join(' • ')}</small>` : ''}
                </div>
                <div class="d-flex gap-2">
                    <button class="btn btn-sm btn-outline-primary" data-add>Queue</button>
                    ${item.loop ? '<span class="badge text-bg-info">Loop</span>' : ''}
                </div>
            </div>`;
            li.querySelector('[data-add]').addEventListener('click', () => addToQueue(item));
            psaList.appendChild(li);
        });
        if (!psaList.children.length) {
            const li = document.createElement('li');
            li.className = 'list-group-item text-muted';
            li.textContent = 'No items found.';
            psaList.appendChild(li);
        }
    }

    function renderQueue() {
        queueList.innerHTML = '';
        if (!queue.length) {
            queueList.innerHTML = '<li class="text-muted">Queue empty.</li>';
            resetTimers();
            if (pushQueueBtn) {
                pushQueueBtn.disabled = true;
            }
            return;
        }
        queue.forEach((item, idx) => {
            const li = document.createElement('li');
            const meta = [];
            if (item.duration) meta.push(`${item.duration}s`);
            if (item.category) meta.push(item.category);
            const introMeta = item.cues && item.cues.intro ? ` (${item.cues.intro.toFixed(1)}s)` : '';
            li.innerHTML = `<div class="d-flex justify-content-between align-items-center">
                <div>${item.name}${introMeta} ${meta.length ? `<small class="text-muted">(${meta.join(' • ')})</small>` : ''}</div>
                <button class="btn btn-sm btn-outline-danger" data-remove>&times;</button>
            </div>`;
            li.dataset.index = idx;
            li.tabIndex = 0;
            li.addEventListener('click', (ev) => {
                if (!ev.target.dataset.remove && controlMode === 'rams') {
                    startFrom(idx);
                }
            });
            li.addEventListener('keydown', (ev) => {
                if (ev.key === 'Enter' && controlMode === 'rams') {
                    startFrom(idx);
                }
            });
            li.querySelector('[data-remove]').addEventListener('click', (ev) => { ev.stopPropagation(); removeFromQueue(idx); });
            queueList.appendChild(li);
        });
        if (pushQueueBtn) {
            pushQueueBtn.disabled = controlMode !== 'radiodj' || !queue.length;
        }
    }

    function updateControlModeUI() {
        const isRadioDJ = controlMode === 'radiodj';
        if (controlModeLabel) {
            controlModeLabel.textContent = isRadioDJ ? 'RadioDJ' : 'RAMS';
            controlModeLabel.className = `badge ${isRadioDJ ? 'text-bg-warning' : 'text-bg-light border'}`;
        }
        if (radiodjOverrideBtn) {
            radiodjOverrideBtn.textContent = isRadioDJ ? 'Return to RAMS' : 'RadioDJ Override';
        }
        if (pushQueueBtn) {
            pushQueueBtn.disabled = !isRadioDJ || !queue.length;
        }
        [togglePauseBtn, playNextBtn, fadeOutBtn, addStopBtn].forEach(btn => {
            if (btn) btn.disabled = isRadioDJ;
        });
        if (isRadioDJ) {
            stopFade();
            stopAllAudio();
            stopTimer();
            togglePauseBtn.textContent = 'Pause';
        }
    }

    function setRadioDJAvailability(enabled) {
        if (radiodjOverrideBtn) {
            radiodjOverrideBtn.disabled = !enabled;
        }
        if (!enabled && controlMode === 'radiodj') {
            controlMode = 'rams';
            updateControlModeUI();
            renderQueue();
        }
    }

    function resetTimers() {
        const text = '00:00.00';
        timerEls.forEach(el => {
            if (!el) return;
            el.textContent = text;
            el.style.color = '';
            el.style.fontWeight = '400';
        });
        introBadge.style.display = 'inline-block';
        introBadge.textContent = 'Intro: 0.0s';
        introBadge.classList.remove('countdown-flash', 'text-bg-danger');
        outroBadge.style.display = 'inline-block';
        outroBadge.textContent = 'Outro: 0.0s';
        outroBadge.classList.remove('countdown-flash', 'text-bg-danger');
        loopBetween.checked = false;
        loopBetween.disabled = true;
        togglePauseBtn.textContent = 'Pause';
    }

    async function setNowPlayingOverride(enabled) {
        try {
            const res = await fetch('/api/now/override', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({enabled})
            });
            if (!res.ok) {
                return false;
            }
            return true;
        } catch (err) {
            return false;
        }
    }

    async function loadOverrideState() {
        try {
            const res = await fetch('/api/now/override');
            const data = await res.json();
            if (res.ok && typeof data.override_enabled === 'boolean') {
                controlMode = data.override_enabled ? 'radiodj' : 'rams';
                updateControlModeUI();
                renderQueue();
            }
        } catch (err) {
            // ignore
        }
    }

    async function loadRadioDJNowPlaying() {
        if (!radiodjStatus || !radiodjTrack) return;
        try {
            const res = await fetch('/api/radiodj/now-playing');
            const data = await res.json();
            if (res.ok && data.track) {
                const track = data.track || {};
                const artist = track.artist || '';
                const title = track.title || '';
                const album = track.album || '';
                const label = [artist, title].filter(Boolean).join(' - ') || album || 'Now playing';
                radiodjTrack.textContent = label;
                radiodjStatus.classList.remove('text-danger');
                setRadioDJAvailability(true);
            } else if (data.status === 'disabled') {
                radiodjTrack.textContent = 'RadioDJ integration disabled.';
                radiodjStatus.classList.add('text-danger');
                setRadioDJAvailability(false);
            } else {
                radiodjTrack.textContent = 'No now-playing data.';
                radiodjStatus.classList.remove('text-danger');
                setRadioDJAvailability(true);
            }
        } catch (err) {
            radiodjTrack.textContent = 'Unable to reach RadioDJ.';
            radiodjStatus.classList.add('text-danger');
            setRadioDJAvailability(false);
        }
    }

    async function pushQueueToRadioDJ() {
        if (controlMode !== 'radiodj') return;
        if (!radiodjQueueStatus) return;
        const items = queue.filter(item => item.token).map(item => ({
            token: item.token,
            name: item.name,
        }));
        if (!items.length) {
            radiodjQueueStatus.textContent = 'No queue items with file references to push.';
            return;
        }
        radiodjQueueStatus.textContent = 'Pushing queue to RadioDJ...';
        try {
            const res = await fetch('/api/radiodj/queue', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({items})
            });
            const data = await res.json();
            if (!res.ok || data.status !== 'ok') {
                radiodjQueueStatus.textContent = data.message || 'Unable to push queue.';
                return;
            }
            const results = data.results || [];
            const okCount = results.filter(r => r.status === 'ok').length;
            const errCount = results.filter(r => r.status !== 'ok').length;
            radiodjQueueStatus.textContent = errCount
                ? `Pushed ${okCount}/${results.length} items; ${errCount} failed.`
                : `Pushed ${okCount} item${okCount === 1 ? '' : 's'} to RadioDJ.`;
        } catch (err) {
            radiodjQueueStatus.textContent = 'Unable to push queue.';
        }
    }

    function previewCues(item) {
        if (!item) { resetTimers(); return; }
        const cues = item.cues || {};
        timerEls.forEach(el => {
            if (!el) return;
            el.textContent = '00:00.00';
            el.style.color = '';
            el.style.fontWeight = '400';
        });
        const introVal = cues.intro ? cues.intro.toFixed(1) : '0.0';
        introBadge.style.display = 'inline-block';
        introBadge.textContent = `Intro: ${introVal}s`;
        introBadge.classList.remove('countdown-flash', 'text-bg-danger');

        const outroVal = cues.outro ? cues.outro.toFixed(1) : '0.0';
        outroBadge.style.display = 'inline-block';
        outroBadge.textContent = `Outro: ${outroVal}s`;
        outroBadge.classList.remove('countdown-flash', 'text-bg-danger');

        const hasLoop = cues.loop_in != null && cues.loop_out != null;
        loopBetween.disabled = !hasLoop;
        if (!hasLoop) loopBetween.checked = false;
    }

    function stopAllAudio() {
        players.forEach(p => { p.el.pause(); p.el.removeAttribute('src'); p.el.volume = 1; });
        currentItem = null;
        resetTimers();
    }

    function addToQueue(item) {
        queue.push(item);
        if (controlMode === 'rams' && queue.length === 1 && activePlayer().paused) {
            startFrom(0);
        }
        renderQueue();
    }

    function removeFromQueue(idx) {
        if (idx < 0 || idx >= queue.length) return;
        queue.splice(idx, 1);
        renderQueue();
    }

    function addStopCue() { queue.push({ name: 'STOP', stop: true }); renderQueue(); }

    const TOP40_RATE = Math.pow(2, 0.5 / 12);
    const OVERLAY_KINDS = ['voicetrack', 'overlay'];

    function preservesPitchOff(el) {
        if (!el) return;
        el.preservesPitch = false;
        el.mozPreservesPitch = false;
        el.webkitPreservesPitch = false;
    }

    function computePlaybackRate(item) {
        const isMusic = item && ((item.kind && item.kind === 'music') || (item.category || '').toLowerCase().includes('music'));
        if (top40.checked && isMusic) {
            return TOP40_RATE;
        }
        return 1.0;
    }

    function applyPlaybackRate(player = activePlayer(), item = currentItem) {
        preservesPitchOff(player);
        player.playbackRate = computePlaybackRate(item);
    }

    function overlayEligible(item) {
        // Only use the overlay deck for dedicated voice tracks/overlays to avoid
        // fighting the main deck when rolling into music intros.
        return item && OVERLAY_KINDS.includes(item.kind);
    }

    function startFrom(idx, preferredIdx = currentIdx) {
        if (controlMode !== 'rams') {
            return;
        }
        const item = queue[idx];
        if (!item) return;
        if (item.stop) {
            queue.splice(0, idx + 1);
            shiftPastStops();
            stopAllAudio();
            renderQueue();
            if (queue.length) previewCues(queue[0]);
            return;
        }
        stopFade();
        const playerObj = players[preferredIdx];
        const otherObj = players[1 - preferredIdx];
        const player = playerObj.el;
        const other = otherObj.el;
        other.pause();
        other.removeAttribute('src');
        other.volume = 1;
        otherObj.item = null;
        currentIdx = preferredIdx;
        currentItem = item;
        playerObj.item = item;
        const cues = item.cues || {};
        const hasLoop = cues.loop_in != null && cues.loop_out != null;
        loopBetween.disabled = !hasLoop;
        if (!hasLoop) loopBetween.checked = false;
        autoNextTriggered = false;
        prestartedIdx = null;
        if (idx > 0) queue.splice(0, idx);
        player.src = item.url;
        player.volume = 1;
        applyPlaybackRate(player, item);
        player.play();
        togglePauseBtn.textContent = 'Pause';
        renderQueue();
    }

    function shiftPastStops() {
        while (queue.length && queue[0].stop) {
            queue.shift();
        }
    }

    function playNext() {
        if (!queue.length) return;
        queue.shift();
        shiftPastStops();
        stopFade();
        stopAllAudio();
        autoNextTriggered = false;
        prestartedIdx = null;
        if (queue.length) {
            startFrom(0);
        } else {
            renderQueue();
        }
    }

    function startNextWithOverlay() {
        if (queue.length <= 1) {
            fadeAndNext();
            return;
        }

        const current = activePlayer();
        const currentPlaying = currentItem;
        const nextItem = queue[1];

        try {
            overlayPlayer.pause();
            overlayPlayer.src = current.src || '';
            overlayPlayer.currentTime = current.currentTime || 0;
            overlayPlayer.playbackRate = computePlaybackRate(currentPlaying);
            overlayPlayer.volume = current.volume;
            if (overlayPlayer.src) {
                overlayPlayer.play().catch(() => {});
            }
        } catch (e) {
            // ignore overlay errors
        }

        current.pause();
        current.removeAttribute('src');

        queue.shift();
        shiftPastStops();

        const nextIdx = 1 - currentIdx;
        const nextObj = players[nextIdx];
        const nextPlayer = nextObj.el;
        stopFade();
        nextObj.item = nextItem;
        nextPlayer.src = nextItem.url;
        nextPlayer.volume = 1;
        currentIdx = nextIdx;
        currentItem = nextItem;
        prestartedIdx = null;
        autoNextTriggered = false;
        applyPlaybackRate(nextPlayer, nextItem);
        nextPlayer.play();
        startTimer();
        renderQueue();
    }

    function fadeAndNext() {
        if (queue.length <= 1 || (queue[1] && queue[1].stop)) {
            playNext();
            return;
        }
        const current = activePlayer();
        const nextIdx = 1 - currentIdx;
        const nextItem = queue[1];
        const nextPlayerObj = players[nextIdx];
        const nextPlayer = nextPlayerObj.el;
        stopFade();
        nextPlayerObj.item = nextItem;
        nextPlayer.src = nextItem.url;
        nextPlayer.volume = 1;
        applyPlaybackRate(nextPlayer, nextItem);
        nextPlayer.play();
        fadeTimer = setInterval(() => {
            current.volume = Math.max(0, current.volume - 0.06);
            if (current.volume <= 0.02) {
                stopFade();
                current.pause();
                current.volume = 1;
                current.removeAttribute('src');
                queue.shift();
                shiftPastStops();
                currentIdx = nextIdx;
                currentItem = nextItem;
                prestartedIdx = null;
                applyPlaybackRate();
                startTimer();
                renderQueue();
            }
        }, 80);
    }

    function stopFade() { if (fadeTimer) { clearInterval(fadeTimer); fadeTimer = null; } }

    function updateTimer() {
        const player = activePlayer();
        if (!currentItem || !player.src || !player.duration || isNaN(player.duration)) {
            resetTimers();
            return;
        }

        const cues = currentItem && currentItem.cues ? currentItem.cues : {};
        let remaining = Math.max(0, player.duration - player.currentTime);
        if (queue.length > 1 && cues.start_next) {
            remaining = Math.max(0, cues.start_next - player.currentTime);
        }

        const minutes = Math.floor(remaining / 60);
        const seconds = Math.floor(remaining % 60);
        const ms = Math.floor((remaining - Math.floor(remaining)) * 100);
        const text = `${String(minutes).padStart(2,'0')}:${String(seconds).padStart(2,'0')}.${String(ms).padStart(2,'0')}`;
        const urgent = remaining > 0 && remaining <= 15;
        timerEls.forEach(el => {
            if (!el) return;
            el.textContent = text;
            el.style.color = urgent ? '#dc3545' : '';
            el.style.fontWeight = urgent ? '700' : '400';
        });

        if (cues.intro) {
            const introRem = Math.max(0, cues.intro - player.currentTime);
            introBadge.style.display = 'inline-block';
            introBadge.textContent = `Intro: ${introRem.toFixed(1)}s`;
            const flash = introRem > 0 && introRem <= 5;
            introBadge.classList.toggle('countdown-flash', flash);
            introBadge.classList.toggle('text-bg-danger', flash);
        } else {
            introBadge.style.display = 'inline-block';
            introBadge.textContent = 'Intro: 0.0s';
            introBadge.classList.remove('countdown-flash','text-bg-danger');
        }

        if (cues.outro) {
            const outroRem = Math.max(0, cues.outro - player.currentTime);
            outroBadge.style.display = 'inline-block';
            outroBadge.textContent = `Outro: ${outroRem.toFixed(1)}s`;
            const flash = outroRem > 0 && outroRem <= 5;
            outroBadge.classList.toggle('countdown-flash', flash);
            outroBadge.classList.toggle('text-bg-danger', flash);
        } else {
            outroBadge.style.display = 'inline-block';
            outroBadge.textContent = 'Outro: 0.0s';
            outroBadge.classList.remove('countdown-flash','text-bg-danger');
        }

        // Auto-advance when start_next cue is hit.
        if (!autoNextTriggered && cues.start_next && player.currentTime >= cues.start_next) {
            autoNextTriggered = true;
            resetTimers();
            if (queue.length > 1) {
                if (overlayEligible(currentItem)) {
                    startNextWithOverlay();
                } else {
                    fadeAndNext();
                }
            }
        }

        if (loopBetween.checked && cues.loop_in != null && cues.loop_out != null) {
            const loopIn = cues.loop_in;
            const loopOut = cues.loop_out;
            if (player.currentTime >= loopOut - 0.05) {
                player.currentTime = loopIn;
                try { player.play(); } catch (e) { /* ignore */ }
            }
        }

        // Voice track smart start for next track intro/outro.
        if (!prestartedIdx && currentItem && currentItem.kind === 'voicetrack' && queue.length > 1) {
            const nextItem = queue[1];
            const nextCues = nextItem.cues || {};
            const target = nextCues.intro || nextCues.outro;
            if (target && remaining <= target + 0.25) {
                const nextIdxDeck = 1 - currentIdx;
                const nextPlayerObj = players[nextIdxDeck];
                const nextPlayer = nextPlayerObj.el;
                nextPlayerObj.item = nextItem;
                nextPlayer.src = nextItem.url;
                nextPlayer.volume = 1;
                applyPlaybackRate(nextPlayer, nextItem);
                try { nextPlayer.play(); } catch (e) { /* ignore */ }
                prestartedIdx = nextIdxDeck;
            }
        }
    }

    function startTimer() { stopTimer(); timerInterval = setInterval(updateTimer, 80); }
    function stopTimer() { if (timerInterval) { clearInterval(timerInterval); timerInterval = null; } }

    function handleEnded(idx) {
        if (idx !== currentIdx) return;
        stopTimer();
        queue.shift();
        shiftPastStops();
        if (queue.length) {
            if (prestartedIdx !== null && players[prestartedIdx].item === queue[0]) {
                currentIdx = prestartedIdx;
                currentItem = queue[0];
                prestartedIdx = null;
                applyPlaybackRate();
                startTimer();
                renderQueue();
            } else {
                startFrom(0);
            }
        } else {
            stopAllAudio();
            renderQueue();
        }
    }

    document.getElementById('clearQueue').addEventListener('click', () => {
        queue.length = 0;
        stopFade();
        stopAllAudio();
        renderQueue();
    });
    togglePauseBtn.addEventListener('click', () => {
        const player = activePlayer();
        if (!currentItem || !player || !player.src) return;
        if (player.paused) {
            player.play();
            togglePauseBtn.textContent = 'Pause';
        } else {
            player.pause();
            togglePauseBtn.textContent = 'Play';
        }
    });
    playNextBtn.addEventListener('click', playNext);
    addStopBtn.addEventListener('click', addStopCue);
    fadeOutBtn.addEventListener('click', fadeAndNext);
    pushQueueBtn.addEventListener('click', pushQueueToRadioDJ);
    document.getElementById('overlayPlay').addEventListener('click', () => {
        const url = document.getElementById('overlayUrl').value.trim();
        if (!url) return;
        overlayPlayer.src = url;
        overlayPlayer.play();
    });

    radiodjOverrideBtn.addEventListener('click', async () => {
        const nextMode = controlMode === 'rams' ? 'radiodj' : 'rams';
        const ok = await setNowPlayingOverride(nextMode === 'radiodj');
        if (!ok) {
            if (radiodjQueueStatus) {
                radiodjQueueStatus.textContent = 'Unable to update now-playing override.';
            }
            return;
        }
        controlMode = nextMode;
        updateControlModeUI();
        renderQueue();
    });

    document.getElementById('psaSearch').addEventListener('input', (e) => renderLibrary(e.target.value || ''));
    categoryFilter.addEventListener('change', () => renderLibrary(document.getElementById('psaSearch').value || ''));
    document.getElementById('refreshPsa').addEventListener('click', () => loadPSAs());
    top40.addEventListener('change', () => {
        players.forEach((p) => {
            preservesPitchOff(p.el);
            if (p.item) {
                p.el.playbackRate = computePlaybackRate(p.item);
            }
        });
    });

    players.forEach((p, idx) => {
        preservesPitchOff(p.el);
        p.el.addEventListener('play', () => { if (idx === currentIdx) { startTimer(); applyPlaybackRate(p.el, p.item); togglePauseBtn.textContent = 'Pause'; } });
        p.el.addEventListener('loadedmetadata', () => { if (p.item) { applyPlaybackRate(p.el, p.item); } });
        p.el.addEventListener('pause', () => { if (idx === currentIdx) { stopTimer(); togglePauseBtn.textContent = 'Play'; } });
        p.el.addEventListener('ended', () => handleEnded(idx));
    });

    overlayPlayer.addEventListener('ended', () => {
        overlayPlayer.pause();
        overlayPlayer.removeAttribute('src');
        overlayPlayer.currentTime = 0;
    });

    async function loadPSAs() {
        try {
            const params = new URLSearchParams({
                page: libraryPage,
                per_page: libraryPerPage,
            });
            if (categoryFilter.value) params.set('category', categoryFilter.value);
            if (libraryQuery) params.set('q', libraryQuery);
            const res = await fetch(`/api/psa/library?${params.toString()}`);
            const data = await res.json();
            library = data.items || [];
            libraryTotal = data.total || 0;
            renderCategories(data.categories || []);
            renderLibrary();
            const start = libraryTotal ? ((data.page - 1) * data.per_page) + 1 : 0;
            const end = Math.min(libraryTotal, data.page * data.per_page);
            libraryMeta.textContent = libraryTotal
                ? `Showing ${start}-${end} of ${libraryTotal}`
                : 'No items found.';
            libraryPrev.disabled = data.page <= 1;
            libraryNext.disabled = end >= libraryTotal;
        } catch (e) {
            psaList.innerHTML = '<li class="list-group-item text-danger">Unable to load media.</li>';
        }
    }
    loadPSAs();
    updateControlModeUI();
    loadOverrideState();
    loadRadioDJNowPlaying();
    setInterval(loadRadioDJNowPlaying, 15000);

    libraryPrev.addEventListener('click', async () => {
        if (libraryPage <= 1) return;
        libraryPage -= 1;
        await loadPSAs();
    });
    libraryNext.addEventListener('click', async () => {
        libraryPage += 1;
        await loadPSAs();
    });
    categoryFilter.addEventListener('change', async () => {
        libraryPage = 1;
        await loadPSAs();
    });
    let searchTimer = null;
    psaSearch.addEventListener('input', () => {
        if (searchTimer) clearTimeout(searchTimer);
        searchTimer = setTimeout(async () => {
            libraryQuery = psaSearch.value.trim();
            libraryPage = 1;
            await loadPSAs();
        }, 250);
    });

    // Voice track recording
    const startRecBtn = document.getElementById('startRecord');
    const stopRecBtn = document.getElementById('stopRecord');
    startRecBtn.addEventListener('click', async () => {
        if (recorder) return;
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            recorder = new MediaRecorder(stream);
            recordChunks = [];
            recorder.ondataavailable = (e) => { if (e.data.size > 0) recordChunks.push(e.data); };
            recorder.onstop = () => {
                const blob = new Blob(recordChunks, { type: 'audio/webm' });
                if (pendingVTUrl) URL.revokeObjectURL(pendingVTUrl);
                pendingVTUrl = URL.createObjectURL(blob);
                pendingVT = { name: 'Voice Track', url: pendingVTUrl, category: 'Voice Tracks', kind: 'voicetrack' };
                document.getElementById('vtPending').classList.remove('d-none');
                recorder = null;
                stopRecBtn.disabled = true;
                startRecBtn.disabled = false;
            };
            recorder.start();
            startRecBtn.disabled = true;
            stopRecBtn.disabled = false;
        } catch (err) {
            alert('Unable to access microphone for recording.');
            recorder = null;
        }
    });
    stopRecBtn.addEventListener('click', () => { if (recorder) recorder.stop(); });

    document.getElementById('vtConfirm').addEventListener('click', () => {
        if (pendingVT) {
            addToQueue(pendingVT);
        }
        document.getElementById('vtPending').classList.add('d-none');
        pendingVT = null;
    });
    document.getElementById('vtDelete').addEventListener('click', () => {
        if (pendingVTUrl) URL.revokeObjectURL(pendingVTUrl);
        pendingVTUrl = null;
        pendingVT = null;
        document.getElementById('vtPending').classList.add('d-none');
    });
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="robots" content="noindex, nofollow">
    <title>PSA Player</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        .countdown-badge {
            font-size: 1.05rem;
            min-width: 120px;
            text-align: center;
        }
        .countdown-flash {
            animation: flash 0.25s steps(1) infinite;
        }
        @keyframes flash {
            50% { opacity: 0.35; }
        }
        .cue-btn.active {
            background: #000;
            color: #fff !important;
        }
    </style>
</head>
<body>
{% include '_nav.html' %}
<div class="container mt-4">
    <div class="d-flex justify-content-between align-items-center mb-3">
        <div>
            <h2 class="mb-0">PSA Player</h2>
            <div class="text-muted">Build a quick queue and play PSAs directly in the browser.</div>
            <div class="help-hint text-info">This page is noindex/nofollow. Share the URL directly with DJs.</div>
        </div>
        <div class="text-muted small">Source: {{ psa_root or 'psa' }}</div>
    </div>
    <div class="row g-3">
        <div class="col-lg-6">
            <div class="card h-100">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <span>Available Media</span>
                    <div class="d-flex gap-2 align-items-center">
                        <button class="btn btn-outline-secondary btn-sm" id="refreshPsa">Refresh</button>
                        <select id="categoryFilter" class="form-select form-select-sm" style="max-width:180px;"></select>
                        <input type="search" id="psaSearch" class="form-control form-control-sm" placeholder="Filter..." style="max-width:200px;">
                    </div>
                </div>
                <div class="card-body" style="max-height:60vh; overflow:auto;">
                    <ul class="list-group" id="psaList"></ul>
                </div>
            </div>
        </div>
        <div class="col-lg-6">
            <div class="card h-100">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <span>Queue</span>
                    <div class="text-muted fw-semibold" style="font-size:1.4rem;">Timer: <span id="timerTop">00:00.00</span></div>
                </div>
                <div class="card-body">
                    <div class="d-flex align-items-center justify-content-between mb-2 flex-wrap gap-2">
                        <div class="fw-semibold" style="font-size:1.8rem;">Timer: <span id="timer">00:00.00</span></div>
                        <div class="d-flex gap-2 align-items-center">
                            <span class="badge rounded-pill text-bg-secondary countdown-badge" id="introBadge" style="display:none;">Intro</span>
                            <span class="badge rounded-pill text-bg-secondary countdown-badge" id="outroBadge" style="display:none;">Outro</span>
                        </div>
                    </div>
                    <audio id="psaAudioA" controls class="w-100 mb-2"></audio>
                    <audio id="psaAudioB" class="w-100 mb-2 d-none"></audio>
                    <audio id="psaAudioOverlay" class="w-100 mb-2"></audio>
                    <div class="d-flex align-items-center justify-content-between mb-2">
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="top40">
                            <label class="form-check-label" for="top40">Top-40 boost (+0.5 semitone on music)</label>
                        </div>
                        <div class="d-flex gap-2">
                            <button class="btn btn-outline-dark btn-sm" id="startRecord">Record VT</button>
                            <button class="btn btn-outline-secondary btn-sm" id="stopRecord" disabled>Stop</button>
                        </div>
                    </div>
                    <div id="vtPending" class="alert alert-info d-none py-2 px-3 mb-2">
                        <div class="d-flex justify-content-between align-items-center flex-wrap gap-2">
                            <div>Pending voice track ready. Add to queue?</div>
                            <div class="d-flex gap-2">
                                <button class="btn btn-sm btn-outline-success" id="vtConfirm">Confirm</button>
                                <button class="btn btn-sm btn-outline-danger" id="vtDelete">Delete</button>
                            </div>
                        </div>
                    </div>
                    <div class="d-flex gap-2 flex-wrap mb-2">
                        <button class="btn btn-outline-secondary btn-sm" id="clearQueue">Clear Queue</button>
                        <button class="btn btn-outline-primary btn-sm" id="playNext">Play Next</button>
                        <button class="btn btn-outline-danger btn-sm" id="fadeOut">Fade & Next</button>
                        <button class="btn btn-outline-dark btn-sm" id="addStop">Add STOP</button>
                    </div>
                    <ol class="mb-0" id="queueList"></ol>
                    <hr>
                    <div class="mb-2 fw-semibold">Overlay Deck</div>
                    <div class="input-group mb-2">
                        <input type="url" class="form-control form-control-sm" id="overlayUrl" placeholder="Paste media URL">
                        <button class="btn btn-outline-primary btn-sm" id="overlayPlay">Play Overlay</button>
                    </div>
                    <div class="text-muted small">Use the overlay deck for ad-hoc beds or carts; it does not affect the queue.</div>
                </div>
            </div>
        </div>
    </div>
</div>
{% include '_footer.html' %}
<script>
    let library = [];
    const psaList = document.getElementById('psaList');
    const queueList = document.getElementById('queueList');
    const timerEls = [document.getElementById('timer'), document.getElementById('timerTop')];
    const categoryFilter = document.getElementById('categoryFilter');
    const top40 = document.getElementById('top40');
    const introBadge = document.getElementById('introBadge');
    const outroBadge = document.getElementById('outroBadge');
    const queue = [];
    const players = [
        { el: document.getElementById('psaAudioA'), item: null },
        { el: document.getElementById('psaAudioB'), item: null }
    ];
    const overlayPlayer = document.getElementById('psaAudioOverlay');
    let currentIdx = 0;
    let currentItem = null;
    let fadeTimer = null;
    let timerInterval = null;
    let recorder = null;
    let recordChunks = [];
    let autoNextTriggered = false;
    let prestartedIdx = null;
    let pendingVT = null;
    let pendingVTUrl = null;

    function activePlayer() { return players[currentIdx].el; }
    function otherPlayer() { return players[1 - currentIdx].el; }

    function renderCategories() {
        const cats = Array.from(new Set(library.map(i => i.category || 'PSA'))).sort();
        categoryFilter.innerHTML = '<option value="">All categories</option>' + cats.map(c => `<option value="${c}">${c}</option>`).join('');
    }

    function renderLibrary(filter = '') {
        psaList.innerHTML = '';
        const term = filter.toLowerCase();
        const cat = categoryFilter.value;
        library.filter(item => item.name.toLowerCase().includes(term) && (!cat || item.category === cat)).forEach(item => {
            const li = document.createElement('li');
            li.className = 'list-group-item';
            const meta = [];
            if (item.duration) meta.push(`${item.duration}s`);
            if (item.loop) meta.push('loop');
            if (item.category) meta.push(item.category);
            li.innerHTML = `<div class="d-flex justify-content-between align-items-center">
                <div>
                    <strong>${item.name}</strong><br>
                    ${meta.length ? `<small class='text-muted'>${meta.join(' • ')}</small>` : ''}
                </div>
                <div class="d-flex gap-2">
                    <button class="btn btn-sm btn-outline-primary" data-add>Queue</button>
                    ${item.loop ? '<span class="badge text-bg-info">Loop</span>' : ''}
                </div>
            </div>`;
            li.querySelector('[data-add]').addEventListener('click', () => addToQueue(item));
            psaList.appendChild(li);
        });
        if (!psaList.children.length) {
            const li = document.createElement('li');
            li.className = 'list-group-item text-muted';
            li.textContent = 'No items found.';
            psaList.appendChild(li);
        }
    }

    function renderQueue() {
        queueList.innerHTML = '';
        if (!queue.length) {
            queueList.innerHTML = '<li class="text-muted">Queue empty.</li>';
            resetTimers();
            return;
        }
        queue.forEach((item, idx) => {
            const li = document.createElement('li');
            const meta = [];
            if (item.duration) meta.push(`${item.duration}s`);
            if (item.category) meta.push(item.category);
            const introMeta = item.cues && item.cues.intro ? ` (${item.cues.intro.toFixed(1)}s)` : '';
            li.innerHTML = `<div class="d-flex justify-content-between align-items-center">
                <div>${item.name}${introMeta} ${meta.length ? `<small class="text-muted">(${meta.join(' • ')})</small>` : ''}</div>
                <button class="btn btn-sm btn-outline-danger" data-remove>&times;</button>
            </div>`;
            li.dataset.index = idx;
            li.tabIndex = 0;
            li.addEventListener('click', (ev) => { if (!ev.target.dataset.remove) startFrom(idx); });
            li.addEventListener('keydown', (ev) => { if (ev.key === 'Enter') startFrom(idx); });
            li.querySelector('[data-remove]').addEventListener('click', (ev) => { ev.stopPropagation(); removeFromQueue(idx); });
            queueList.appendChild(li);
        });
    }

    function resetTimers() {
        const text = '00:00.00';
        timerEls.forEach(el => {
            if (!el) return;
            el.textContent = text;
            el.style.color = '';
            el.style.fontWeight = '400';
        });
        introBadge.style.display = 'inline-block';
        introBadge.textContent = 'Intro: 0.0s';
        introBadge.classList.remove('countdown-flash', 'text-bg-danger');
        outroBadge.style.display = 'inline-block';
        outroBadge.textContent = 'Outro: 0.0s';
        outroBadge.classList.remove('countdown-flash', 'text-bg-danger');
    }

    function previewCues(item) {
        if (!item) { resetTimers(); return; }
        const cues = item.cues || {};
        timerEls.forEach(el => {
            if (!el) return;
            el.textContent = '00:00.00';
            el.style.color = '';
            el.style.fontWeight = '400';
        });
        const introVal = cues.intro ? cues.intro.toFixed(1) : '0.0';
        introBadge.style.display = 'inline-block';
        introBadge.textContent = `Intro: ${introVal}s`;
        introBadge.classList.remove('countdown-flash', 'text-bg-danger');

        const outroVal = cues.outro ? cues.outro.toFixed(1) : '0.0';
        outroBadge.style.display = 'inline-block';
        outroBadge.textContent = `Outro: ${outroVal}s`;
        outroBadge.classList.remove('countdown-flash', 'text-bg-danger');
    }

    function stopAllAudio() {
        players.forEach(p => { p.el.pause(); p.el.removeAttribute('src'); p.el.volume = 1; });
        currentItem = null;
        resetTimers();
    }

    function addToQueue(item) {
        queue.push(item);
        if (queue.length === 1 && activePlayer().paused) {
            startFrom(0);
        }
        renderQueue();
    }

    function removeFromQueue(idx) {
        if (idx < 0 || idx >= queue.length) return;
        queue.splice(idx, 1);
        renderQueue();
    }

    function addStopCue() { queue.push({ name: 'STOP', stop: true }); renderQueue(); }

    const TOP40_RATE = Math.pow(2, 0.5 / 12);
    const OVERLAY_KINDS = ['voicetrack', 'overlay'];

    function preservesPitchOff(el) {
        if (!el) return;
        el.preservesPitch = false;
        el.mozPreservesPitch = false;
        el.webkitPreservesPitch = false;
    }

    function computePlaybackRate(item) {
        const isMusic = item && ((item.kind && item.kind === 'music') || (item.category || '').toLowerCase().includes('music'));
        if (top40.checked && isMusic) {
            return TOP40_RATE;
        }
        return 1.0;
    }

    function applyPlaybackRate(player = activePlayer(), item = currentItem) {
        preservesPitchOff(player);
        player.playbackRate = computePlaybackRate(item);
    }

    function overlayEligible(item) {
        if (!item) return false;
        const cat = (item.category || '').toLowerCase();
        return OVERLAY_KINDS.includes(item.kind) || cat.includes('sweeper') || cat.includes('imaging');
    }

    function startFrom(idx, preferredIdx = currentIdx) {
        const item = queue[idx];
        if (!item) return;
        if (item.stop) {
            queue.splice(0, idx + 1);
            shiftPastStops();
            stopAllAudio();
            renderQueue();
            if (queue.length) previewCues(queue[0]);
            return;
        }
        stopFade();
        const playerObj = players[preferredIdx];
        const otherObj = players[1 - preferredIdx];
        const player = playerObj.el;
        const other = otherObj.el;
        other.pause();
        other.removeAttribute('src');
        other.volume = 1;
        otherObj.item = null;
        currentIdx = preferredIdx;
        currentItem = item;
        playerObj.item = item;
        autoNextTriggered = false;
        prestartedIdx = null;
        if (idx > 0) queue.splice(0, idx);
        player.src = item.url;
        player.volume = 1;
        applyPlaybackRate(player, item);
        player.play();
        renderQueue();
    }

    function shiftPastStops() {
        while (queue.length && queue[0].stop) {
            queue.shift();
        }
    }

    function playNext() {
        if (!queue.length) return;
        queue.shift();
        shiftPastStops();
        stopFade();
        stopAllAudio();
        autoNextTriggered = false;
        prestartedIdx = null;
        if (queue.length) {
            startFrom(0);
        } else {
            renderQueue();
        }
    }

    function startNextWithOverlay() {
        if (queue.length <= 1) {
            fadeAndNext();
            return;
        }

        const current = activePlayer();
        const currentPlaying = currentItem;
        const nextItem = queue[1];

        try {
            overlayPlayer.pause();
            overlayPlayer.src = current.src || '';
            overlayPlayer.currentTime = current.currentTime || 0;
            overlayPlayer.playbackRate = computePlaybackRate(currentPlaying);
            overlayPlayer.volume = current.volume;
            if (overlayPlayer.src) {
                overlayPlayer.play().catch(() => {});
            }
        } catch (e) {
            // ignore overlay errors
        }

        current.pause();
        current.removeAttribute('src');

        queue.shift();
        shiftPastStops();

        const nextIdx = 1 - currentIdx;
        const nextObj = players[nextIdx];
        const nextPlayer = nextObj.el;
        stopFade();
        nextObj.item = nextItem;
        nextPlayer.src = nextItem.url;
        nextPlayer.volume = 1;
        currentIdx = nextIdx;
        currentItem = nextItem;
        prestartedIdx = null;
        autoNextTriggered = false;
        applyPlaybackRate(nextPlayer, nextItem);
        nextPlayer.play();
        startTimer();
        renderQueue();
    }

    function fadeAndNext() {
        if (queue.length <= 1 || (queue[1] && queue[1].stop)) {
            playNext();
            return;
        }
        const current = activePlayer();
        const nextIdx = 1 - currentIdx;
        const nextItem = queue[1];
        const nextPlayerObj = players[nextIdx];
        const nextPlayer = nextPlayerObj.el;
        stopFade();
        nextPlayerObj.item = nextItem;
        nextPlayer.src = nextItem.url;
        nextPlayer.volume = 1;
        applyPlaybackRate(nextPlayer, nextItem);
        nextPlayer.play();
        fadeTimer = setInterval(() => {
            current.volume = Math.max(0, current.volume - 0.06);
            if (current.volume <= 0.02) {
                stopFade();
                current.pause();
                current.volume = 1;
                current.removeAttribute('src');
                queue.shift();
                shiftPastStops();
                currentIdx = nextIdx;
                currentItem = nextItem;
                prestartedIdx = null;
                applyPlaybackRate();
                startTimer();
                renderQueue();
            }
        }, 80);
    }

    function stopFade() { if (fadeTimer) { clearInterval(fadeTimer); fadeTimer = null; } }

    function updateTimer() {
        const player = activePlayer();
        if (!currentItem || !player.src || !player.duration || isNaN(player.duration)) {
            resetTimers();
            return;
        }

        const cues = currentItem && currentItem.cues ? currentItem.cues : {};
        let remaining = Math.max(0, player.duration - player.currentTime);
        if (queue.length > 1 && cues.start_next) {
            remaining = Math.max(0, cues.start_next - player.currentTime);
        }

        const minutes = Math.floor(remaining / 60);
        const seconds = Math.floor(remaining % 60);
        const ms = Math.floor((remaining - Math.floor(remaining)) * 100);
        const text = `${String(minutes).padStart(2,'0')}:${String(seconds).padStart(2,'0')}.${String(ms).padStart(2,'0')}`;
        const urgent = remaining > 0 && remaining <= 15;
        timerEls.forEach(el => {
            if (!el) return;
            el.textContent = text;
            el.style.color = urgent ? '#dc3545' : '';
            el.style.fontWeight = urgent ? '700' : '400';
        });

        if (cues.intro) {
            const introRem = Math.max(0, cues.intro - player.currentTime);
            introBadge.style.display = 'inline-block';
            introBadge.textContent = `Intro: ${introRem.toFixed(1)}s`;
            const flash = introRem > 0 && introRem <= 5;
            introBadge.classList.toggle('countdown-flash', flash);
            introBadge.classList.toggle('text-bg-danger', flash);
        } else {
            introBadge.style.display = 'inline-block';
            introBadge.textContent = 'Intro: 0.0s';
            introBadge.classList.remove('countdown-flash','text-bg-danger');
        }

        if (cues.outro) {
            const outroRem = Math.max(0, cues.outro - player.currentTime);
            outroBadge.style.display = 'inline-block';
            outroBadge.textContent = `Outro: ${outroRem.toFixed(1)}s`;
            const flash = outroRem > 0 && outroRem <= 5;
            outroBadge.classList.toggle('countdown-flash', flash);
            outroBadge.classList.toggle('text-bg-danger', flash);
        } else {
            outroBadge.style.display = 'inline-block';
            outroBadge.textContent = 'Outro: 0.0s';
            outroBadge.classList.remove('countdown-flash','text-bg-danger');
        }

        // Auto-advance when start_next cue is hit.
        if (!autoNextTriggered && cues.start_next && player.currentTime >= cues.start_next) {
            autoNextTriggered = true;
            resetTimers();
            if (queue.length > 1) {
                if (overlayEligible(currentItem)) {
                    startNextWithOverlay();
                } else {
                    fadeAndNext();
                }
            }
        }

        // Voice track smart start for next track intro/outro.
        if (!prestartedIdx && currentItem && currentItem.kind === 'voicetrack' && queue.length > 1) {
            const nextItem = queue[1];
            const nextCues = nextItem.cues || {};
            const target = nextCues.intro || nextCues.outro;
            if (target && remaining <= target + 0.25) {
                const nextIdxDeck = 1 - currentIdx;
                const nextPlayerObj = players[nextIdxDeck];
                const nextPlayer = nextPlayerObj.el;
                nextPlayerObj.item = nextItem;
                nextPlayer.src = nextItem.url;
                nextPlayer.volume = 1;
                applyPlaybackRate(nextPlayer, nextItem);
                try { nextPlayer.play(); } catch (e) { /* ignore */ }
                prestartedIdx = nextIdxDeck;
            }
        }
    }

    function startTimer() { stopTimer(); timerInterval = setInterval(updateTimer, 80); }
    function stopTimer() { if (timerInterval) { clearInterval(timerInterval); timerInterval = null; } }

    function handleEnded(idx) {
        if (idx !== currentIdx) return;
        stopTimer();
        queue.shift();
        shiftPastStops();
        if (queue.length) {
            if (prestartedIdx !== null && players[prestartedIdx].item === queue[0]) {
                currentIdx = prestartedIdx;
                currentItem = queue[0];
                prestartedIdx = null;
                applyPlaybackRate();
                startTimer();
                renderQueue();
            } else {
                startFrom(0);
            }
        } else {
            stopAllAudio();
            renderQueue();
        }
    }

    document.getElementById('clearQueue').addEventListener('click', () => {
        queue.length = 0;
        stopFade();
        stopAllAudio();
        renderQueue();
    });
    document.getElementById('playNext').addEventListener('click', playNext);
    document.getElementById('addStop').addEventListener('click', addStopCue);
    document.getElementById('fadeOut').addEventListener('click', fadeAndNext);
    document.getElementById('overlayPlay').addEventListener('click', () => {
        const url = document.getElementById('overlayUrl').value.trim();
        if (!url) return;
        overlayPlayer.src = url;
        overlayPlayer.play();
    });

    document.getElementById('psaSearch').addEventListener('input', (e) => renderLibrary(e.target.value || ''));
    categoryFilter.addEventListener('change', () => renderLibrary(document.getElementById('psaSearch').value || ''));
    document.getElementById('refreshPsa').addEventListener('click', () => loadPSAs());
    top40.addEventListener('change', () => {
        players.forEach((p) => {
            preservesPitchOff(p.el);
            if (p.item) {
                p.el.playbackRate = computePlaybackRate(p.item);
            }
        });
    });

    players.forEach((p, idx) => {
        preservesPitchOff(p.el);
        p.el.addEventListener('play', () => { if (idx === currentIdx) { startTimer(); applyPlaybackRate(p.el, p.item); } });
        p.el.addEventListener('loadedmetadata', () => { if (p.item) { applyPlaybackRate(p.el, p.item); } });
        p.el.addEventListener('pause', () => { if (idx === currentIdx) stopTimer(); });
        p.el.addEventListener('ended', () => handleEnded(idx));
    });

    overlayPlayer.addEventListener('ended', () => {
        overlayPlayer.pause();
        overlayPlayer.removeAttribute('src');
        overlayPlayer.currentTime = 0;
    });

    async function loadPSAs() {
        try {
            const res = await fetch('/api/psa/library');
            library = await res.json();
            renderCategories();
            renderLibrary();
        } catch (e) {
            psaList.innerHTML = '<li class="list-group-item text-danger">Unable to load media.</li>';
        }
    }
    loadPSAs();

    // Voice track recording
    const startRecBtn = document.getElementById('startRecord');
    const stopRecBtn = document.getElementById('stopRecord');
    startRecBtn.addEventListener('click', async () => {
        if (recorder) return;
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            recorder = new MediaRecorder(stream);
            recordChunks = [];
            recorder.ondataavailable = (e) => { if (e.data.size > 0) recordChunks.push(e.data); };
            recorder.onstop = () => {
                const blob = new Blob(recordChunks, { type: 'audio/webm' });
                if (pendingVTUrl) URL.revokeObjectURL(pendingVTUrl);
                pendingVTUrl = URL.createObjectURL(blob);
                pendingVT = { name: 'Voice Track', url: pendingVTUrl, category: 'Voice Tracks', kind: 'voicetrack' };
                document.getElementById('vtPending').classList.remove('d-none');
                recorder = null;
                stopRecBtn.disabled = true;
                startRecBtn.disabled = false;
            };
            recorder.start();
            startRecBtn.disabled = true;
            stopRecBtn.disabled = false;
        } catch (err) {
            alert('Unable to access microphone for recording.');
            recorder = null;
        }
    });
    stopRecBtn.addEventListener('click', () => { if (recorder) recorder.stop(); });

    document.getElementById('vtConfirm').addEventListener('click', () => {
        if (pendingVT) {
            addToQueue(pendingVT);
        }
        document.getElementById('vtPending').classList.add('d-none');
        pendingVT = null;
    });
    document.getElementById('vtDelete').addEventListener('click', () => {
        if (pendingVTUrl) URL.revokeObjectURL(pendingVTUrl);
        pendingVTUrl = null;
        pendingVT = null;
        document.getElementById('vtPending').classList.add('d-none');
    });
</script>
</body>
</html>
